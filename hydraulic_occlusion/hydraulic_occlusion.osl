/*
 * This file is part of Jakub Jaszewski OSL repository.
 * https://github.com/j-jasz/OSL
 * Copyright (C) 2025 Jakub Jaszewski.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

void unit_disk (vector N,
                        vector Normal,
                        float Angle,
                        float rand,
                        output float x_dir,
                        output float y_dir
){
    vector Dir = N - dot(N, Normal) * Normal;
    Dir = normalize(Dir);
    float max_angle = Angle * M_PI / 2;
    float fin_angle = rand * max_angle * 2 - max_angle;
    float theta = atan2(Dir[1], Dir[0]) + fin_angle;
    x_dir = cos(theta);
    y_dir = sin(theta);
}

shader hydraulic_occlusion(
    int Samples = 4,
    float Distance = 1.0,
    float Angle = 1.0,
    vector Normal = vector(0, 0, 1),
    output color Hydraulic_Occlusion = 0
) {
    int i;
    int hit_count = 0;
    float x_dir, y_dir;
    float rand;
    float mixage = 0.0;
    float seed = hashnoise(P, 123456.0);
    seed = fmod(seed, 1.0);
    Hydraulic_Occlusion = color(0, 0, 0);

    if (dot(N, I) > 0) {
        for (i = 0; i < Samples; i++) {
            rand = hashnoise(P, seed + i * 0.1);
            unit_disk(N, Normal, Angle, rand, x_dir, y_dir);
            vector ray_dir = vector(x_dir, y_dir, 0);
            float t = trace(P, ray_dir, "maxdist", Distance);

            if (trace(P, ray_dir, "maxdist", Distance)) {
                hit_count++;
                mixage += clamp(t / Distance, 0.0, 1.0);
            }
        }
        mixage /= Samples;
        color ColorHit = color(0.0, 0.0, 0.0);
        color ColorIn = color(1.0, 1.0, 1.0);
        Hydraulic_Occlusion = mix(ColorHit, ColorIn, mixage);
    }
}





